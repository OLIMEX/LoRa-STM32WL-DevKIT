/* This file is part of the libopencm3 project.
 *
 * It was generated by the irq2nvic_h script.
 *
 * This part needs to get included in the compilation unit where
 * blocking_handler gets defined due to the way #pragma works.
 */


/** @defgroup CM3_nvic_isrdecls_PAC55XX User interrupt service routines (ISR) defaults for PAC55XX Series
    @ingroup CM3_nvic_isrdecls

    @{*/

void memctl_isr(void) __attribute__((weak, alias("blocking_handler")));
void wdt_isr(void) __attribute__((weak, alias("blocking_handler")));
void rtc_isr(void) __attribute__((weak, alias("blocking_handler")));
void adc0_isr(void) __attribute__((weak, alias("blocking_handler")));
void adc1_isr(void) __attribute__((weak, alias("blocking_handler")));
void adc2_isr(void) __attribute__((weak, alias("blocking_handler")));
void adc3_isr(void) __attribute__((weak, alias("blocking_handler")));
void timera_isr(void) __attribute__((weak, alias("blocking_handler")));
void timerb_isr(void) __attribute__((weak, alias("blocking_handler")));
void timerc_isr(void) __attribute__((weak, alias("blocking_handler")));
void timerd_isr(void) __attribute__((weak, alias("blocking_handler")));
void timera_qep_isr(void) __attribute__((weak, alias("blocking_handler")));
void timerb_qep_isr(void) __attribute__((weak, alias("blocking_handler")));
void timerc_qep_isr(void) __attribute__((weak, alias("blocking_handler")));
void timerd_qep_isr(void) __attribute__((weak, alias("blocking_handler")));
void gpioa_isr(void) __attribute__((weak, alias("blocking_handler")));
void gpiob_isr(void) __attribute__((weak, alias("blocking_handler")));
void gpioc_isr(void) __attribute__((weak, alias("blocking_handler")));
void gpiod_isr(void) __attribute__((weak, alias("blocking_handler")));
void gpioe_isr(void) __attribute__((weak, alias("blocking_handler")));
void gpiof_isr(void) __attribute__((weak, alias("blocking_handler")));
void gpiog_isr(void) __attribute__((weak, alias("blocking_handler")));
void i2c_isr(void) __attribute__((weak, alias("blocking_handler")));
void usarta_isr(void) __attribute__((weak, alias("blocking_handler")));
void usartb_isr(void) __attribute__((weak, alias("blocking_handler")));
void usartc_isr(void) __attribute__((weak, alias("blocking_handler")));
void usartd_isr(void) __attribute__((weak, alias("blocking_handler")));
void can_isr(void) __attribute__((weak, alias("blocking_handler")));
void gptimera_isr(void) __attribute__((weak, alias("blocking_handler")));
void gptimerb_isr(void) __attribute__((weak, alias("blocking_handler")));
void scc_isr(void) __attribute__((weak, alias("blocking_handler")));

/**@}*/

/* Initialization template for the interrupt vector table. This definition is
 * used by the startup code generator (vector.c) to set the initial values for
 * the interrupt handling routines to the chip family specific _isr weak
 * symbols. */

#define IRQ_HANDLERS \
    [NVIC_MEMCTL_IRQ] = memctl_isr, \
    [NVIC_WDT_IRQ] = wdt_isr, \
    [NVIC_RTC_IRQ] = rtc_isr, \
    [NVIC_ADC0_IRQ] = adc0_isr, \
    [NVIC_ADC1_IRQ] = adc1_isr, \
    [NVIC_ADC2_IRQ] = adc2_isr, \
    [NVIC_ADC3_IRQ] = adc3_isr, \
    [NVIC_TIMERA_IRQ] = timera_isr, \
    [NVIC_TIMERB_IRQ] = timerb_isr, \
    [NVIC_TIMERC_IRQ] = timerc_isr, \
    [NVIC_TIMERD_IRQ] = timerd_isr, \
    [NVIC_TIMERA_QEP_IRQ] = timera_qep_isr, \
    [NVIC_TIMERB_QEP_IRQ] = timerb_qep_isr, \
    [NVIC_TIMERC_QEP_IRQ] = timerc_qep_isr, \
    [NVIC_TIMERD_QEP_IRQ] = timerd_qep_isr, \
    [NVIC_GPIOA_IRQ] = gpioa_isr, \
    [NVIC_GPIOB_IRQ] = gpiob_isr, \
    [NVIC_GPIOC_IRQ] = gpioc_isr, \
    [NVIC_GPIOD_IRQ] = gpiod_isr, \
    [NVIC_GPIOE_IRQ] = gpioe_isr, \
    [NVIC_GPIOF_IRQ] = gpiof_isr, \
    [NVIC_GPIOG_IRQ] = gpiog_isr, \
    [NVIC_I2C_IRQ] = i2c_isr, \
    [NVIC_USARTA_IRQ] = usarta_isr, \
    [NVIC_USARTB_IRQ] = usartb_isr, \
    [NVIC_USARTC_IRQ] = usartc_isr, \
    [NVIC_USARTD_IRQ] = usartd_isr, \
    [NVIC_CAN_IRQ] = can_isr, \
    [NVIC_GPTIMERA_IRQ] = gptimera_isr, \
    [NVIC_GPTIMERB_IRQ] = gptimerb_isr, \
    [NVIC_SCC_IRQ] = scc_isr
